import logging
import json
from typing import Dict, Any
import uuid
from datetime import datetime
import re

from scripts.models.schemas import Node, WorkflowExecuteRequest, DispatcherCallbackRequest
from scripts.services.giga_chat import GigaChatAPI
from scripts.utils.template_engine import replace_templates
from scripts.services.storage import get_workflow_by_id

logger = logging.getLogger(__name__)

# –•—Ä–∞–Ω–∏–ª–∏—â–µ —Å–µ—Å—Å–∏–π —Ç–µ–ø–µ—Ä—å –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç —ç—Ç–æ–º—É –º–æ–¥—É–ª—é
dispatcher_sessions: Dict[str, Dict[str, Any]] = {}

# --- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ --- 

async def launch_workflow_by_id(workflow_id: str, input_data: Dict[str, Any]):
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç workflow –ø–æ ID"""
    from scripts.core.workflow_engine import execute_workflow_internal
    workflow_data_raw = await get_workflow_by_id(workflow_id)
    if not workflow_data_raw:
        raise Exception(f"Workflow {workflow_id} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö workflow")
    
    logger.info(f"üöÄ –ó–∞–ø—É—Å–∫ workflow {workflow_id}")
    
    workflow_data = dict(workflow_data_raw)
    nodes = json.loads(workflow_data.get('nodes', '[]'))
    connections = json.loads(workflow_data.get('connections', '[]'))

    workflow_request = WorkflowExecuteRequest(
        nodes=nodes,
        connections=connections
    )
    
    # –í –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–º –º–∏—Ä–µ –º—ã –Ω–µ –º–æ–∂–µ–º –ø—Ä–æ—Å—Ç–æ –∂–¥–∞—Ç—å. 
    # –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –±—É–¥–µ—Ç –∑–∞–ø—É—Å–∫–∞—Ç—å —ç—Ç–æ –∫–∞–∫ —Ñ–æ–Ω–æ–≤—É—é –∑–∞–¥–∞—á—É.
    # –ù–æ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ª–æ–≥–∏–∫–∏ –ø–æ–∫–∞ –æ—Å—Ç–∞–≤–∏–º await.
    result = await execute_workflow_internal(workflow_request, initial_input_data=input_data)
    
    # –í —Ä–µ–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ —ç—Ç–æ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–æ–ª–∂–µ–Ω –±—ã–ª –±—ã –æ—Ç–ø—Ä–∞–≤–∏—Ç—å—Å—è 
    # –Ω–∞ —ç–Ω–¥–ø–æ–∏–Ω—Ç /dispatcher/callback, –∞ –Ω–µ –ø—Ä–æ—Å—Ç–æ –≤–µ—Ä–Ω—É—Ç—å—Å—è.
    return result

async def re_plan_in_memory(session: Dict[str, Any]) -> Dict[str, Any]:
    """
    Analyzes the current state of a session and creates a new plan.
    This is the 'brain' of the agent mode.
    """
    logger.info(f"üß† Agent is re-planning for session {session.get('dispatcher_id')}")
    
    config = session.get("dispatcher_config", {})
    initial_query = session.get("initial_query", "")
    history = session.get("execution_history", [])

    # 1. Instantiate a GigaChat API client
    gigachat_api = GigaChatAPI()
    auth_token = config.get('dispatcherAuthToken', '')
    if not auth_token:
        raise Exception("Auth token for dispatcher not found in session config.")

    # 2. Format the history for the prompt
    history_str = ""
    for i, record in enumerate(history):
        step_info = record.get("step_info", {})
        result = record.get("result", {})
        history_str += f"–®–∞–≥ {i+1}: –Ø –≤—ã–ø–æ–ª–Ω–∏–ª –≤–æ—Ä–∫—Ñ–ª–æ—É `{step_info.get('workflow_id')}` —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º `{step_info.get('description')}`.\n"
        history_str += f"–†–µ–∑—É–ª—å—Ç–∞—Ç: {json.dumps(result, ensure_ascii=False, indent=2)}\n\n"

    # 3. Get available workflows from the stored config
    available_workflows = config.get('availableWorkflows', {})
    if not available_workflows:
         # If there are no tools, we can't make a new plan.
        logger.warning("No available workflows found in dispatcher config for re-planning. Aborting.")
        session['plan'] = []
        return session

    workflows_description = "\n".join([
        f"- {wf_id}: {wf_config.get('description', '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç')}"
        for wf_id, wf_config in available_workflows.items()
    ])

    # 4. Build the re-planning prompt
    re_planning_prompt = f"""
===–ò–∑–∏–∞–≥–∞–¥–∞ –∑–∞–¥–∞—á–∞ ===
{initial_query}

===–ß—Ç–æ —É–∂–µ —Å–¥–µ–ª–∞–Ω–æ (–ò—Å—Ç–æ—Ä–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è) ===
{history_str if history_str else "–ï—â–µ –Ω–∏—á–µ–≥–æ –Ω–µ —Å–¥–µ–ª–∞–Ω–æ."} 

===–î–æ—Å—Ç—É–ø–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã (–≤–æ—Ä–∫—Ñ–ª–æ—É) –¥–ª—è —Å–ª–µ–¥—É—â–µ–≥–æ —à–∞–≥–∞ ===
{workflows_description}

===–ù–æ–≤–∞—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è ===
–û—Å–Ω–æ–≤—ã–≤–∞—è—Å—å –Ω–∞ –∏–∑–∏–∑–∞–≥–∞–¥–∞–¥–∞ –∑–∞–¥–∞—á—É –∏ –∏—Å—Ç–æ—Ä–∏–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö —à–∞–≥–æ–≤, —Ä–µ—à–∏, –∫–∞–∫–æ–π –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å–ª–µ–¥—É—é—â–∏–π —à–∞–≥.
–°–æ–∑–¥–∞–π –û–ë–ù–û–í–õ–ï–ù–ù–´–ô –ò –ü–û–õ–ù–´–ô –ø–ª–∞–Ω –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è –¥–µ–π—Å—Ç–≤–∏–π –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON –º–∞—Å—Å–∏–≤–∞ –≤–∏–¥–∞ [{{"workflow_id": "id", "description": "desc"}}].
- –ï—Å–ª–∏ –∑–∞–¥–∞—á–∞ —É–∂–µ —Ä–µ—à–µ–Ω–∞, –≤–µ—Ä–Ω–∏ –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ [].
- –ï—Å–ª–∏ —Å–ª–µ–¥—É—é—â–∏–π —à–∞–≥ –æ—á–µ–≤–∏–¥–µ–Ω, –≤–µ—Ä–Ω–∏ –ø–ª–∞–Ω –∏–∑ –æ–¥–Ω–æ–≥–æ —ç—Ç–æ–≥–æ —à–∞–≥–∞.
- –ï—Å–ª–∏ –∑–∞–¥–∞—á–∞ —Å–ª–æ–∂–Ω–∞—è, —Ä–∞–∑–±–µ–π –µ–µ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ —à–∞–≥–æ–≤.
- –ò—Å–ø–æ–ª—å–∑—É–π —Ç–æ–ª—å–∫–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –∏–∑ —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö.
–û—Ç–≤–µ—á–∞–π –¢–û–õ–¨–ö–û JSON –º–∞—Å—Å–∏–≤–æ–º, –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞.
"""
    logger.info(f"ü§ñ Re-planning prompt for GigaChat:\n{re_planning_prompt}")

    # 5. Call GigaChat to get the new plan
    if await gigachat_api.get_token(auth_token):
        result = await gigachat_api.get_chat_completion(
            "You are an advanced AI agent that analyzes completed work and plans the next steps.",
            re_planning_prompt
        )
        try:
            # Clean up potential markdown code blocks
            raw_response_text = result.get('response', '[]')
            match = re.search(r'```(json)?\s*([\s\S]*?)\s*```', raw_response_text)
            if match:
                cleaned_response_text = match.group(2)
            else:
                cleaned_response_text = raw_response_text

            new_plan = json.loads(cleaned_response_text)
            if not isinstance(new_plan, list):
                raise ValueError("New plan must be a list.")
            
            logger.info(f"‚úÖ Agent received a new plan with {len(new_plan)} steps.")
            session['plan'] = new_plan
        except (json.JSONDecodeError, ValueError) as e:
            logger.error(f"Error parsing new plan from LLM: {result.get('response')}. Error: {e}")
            # On failure, abort by returning an empty plan.
            session['plan'] = []
    else:
        raise Exception("Failed to get GigaChat token for re-planning.")

    return session


async def handle_workflow_return(dispatcher_id: str, sessions: Dict, input_data: Dict[str, Any]):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–æ–∑–≤—Ä–∞—Ç –æ—Ç workflow"""
    session_id = input_data.get('session_id')
    if not session_id or session_id not in sessions:
        raise Exception(f"–°–µ—Å—Å–∏—è {session_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–µ {dispatcher_id}")
    
    session = sessions[session_id]
    
    # Save result of the completed step to the history
    if session['current_step'] < len(session['plan']):
        completed_step_info = session['plan'][session['current_step']]
        step_result = input_data.get('workflow_result', {})
        session['execution_history'].append({
            "step_info": completed_step_info,
            "result": step_result,
            "timestamp": datetime.now().isoformat()
        })

    # Check for agent mode and re-plan if enabled
    if session.get('is_agent_mode', False):
        logger.info(f"Agent mode enabled for session {session_id}. Re-planning...")
        session = await re_plan_in_memory(session)
        # After re-planning, we start from the beginning of the new plan
        session['current_step'] = 0
    else:
        # In simple orchestrator mode, just move to the next step
        session['current_step'] += 1
    
    # Check if the plan is complete
    if session['current_step'] >= len(session['plan']):
        logger.info(f"‚úÖ –ü–ª–∞–Ω –¥–ª—è —Å–µ—Å—Å–∏–∏ {session_id} –≤—ã–ø–æ–ª–Ω–µ–Ω –ø–æ–ª–Ω–æ—Å—Ç—å—é")
        final_result = {
            "success": True,
            "message": "–ü–ª–∞–Ω –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ",
            "results": session['execution_history'] # Return the full history
        }
        del sessions[session_id]
        return final_result

    # Launch the next step
    next_step = session['plan'][session['current_step']]
    next_workflow_id = next_step.get('workflow_id')
    logger.info(f"‚û°Ô∏è –ü–µ—Ä–µ—Ö–æ–¥ –∫ —à–∞–≥—É {session['current_step']}: {next_workflow_id}")
    
    last_step_result = session['execution_history'][-1]['result'] if session['execution_history'] else {}

    workflow_input = {
        "initial_query": session.get('initial_query', ''),
        "execution_history": session['execution_history'],
        "last_step_result": last_step_result,
        "dispatcher_context": {
            "session_id": session_id,
            "plan": session['plan'],
            "step": session['current_step'],
            "dispatcher_id": dispatcher_id
        }
    }
    return await launch_workflow_by_id(next_workflow_id, workflow_input)

async def create_execution_plan(config: Dict, user_query: str, gigachat_api: GigaChatAPI):
    """–°–æ–∑–¥–∞–µ—Ç –ø–ª–∞–Ω –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —á–µ—Ä–µ–∑ GigaChat"""
    available_workflows = config.get('availableWorkflows', {})
    auth_token = config.get('dispatcherAuthToken', '')
    
    if not auth_token:
        raise Exception("–¢–æ–∫–µ–Ω –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –¥–ª—è –ø–ª–∞–Ω–∏—Ä—É—é—â–µ–≥–æ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞ –Ω–µ —É–∫–∞–∑–∞–Ω")
    if not available_workflows:
        raise Exception("–î–æ—Å—Ç—É–ø–Ω—ã–µ workflow –¥–ª—è –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–µ —É–∫–∞–∑–∞–Ω—ã")
    
    workflows_description = "\n".join([
        f"- {wf_id}: {wf_config.get('description', '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç')}"
        for wf_id, wf_config in available_workflows.items()
    ])

    planning_prompt = f"""
    –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–æ—Å–∏—Ç: "{user_query}"
    –î–æ—Å—Ç—É–ø–Ω—ã–µ workflow –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è:
    {workflows_description}
    –°–æ–∑–¥–∞–π –ø–æ—à–∞–≥–æ–≤—ã–π –ø–ª–∞–Ω –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON –º–∞—Å—Å–∏–≤–∞ –≤–∏–¥–∞ [{{"workflow_id": "id", "description": "desc"}}].
    –ü–æ–ª–µ 'description' –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ –∏ –∫—Ä–∞—Ç–∫–æ –æ–±—ä—è—Å–Ω—è—Ç—å, –ø–æ—á–µ–º—É —Ç—ã –≤—ã–±—Ä–∞–ª —ç—Ç–æ—Ç —à–∞–≥.
    –û—Ç–≤–µ—á–∞–π –¢–û–õ–¨–ö–û JSON –º–∞—Å—Å–∏–≤–æ–º, –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞.
    """
    
    logger.info(f"–ü–ª–∞–Ω–∏—Ä—É—é—â–∏–π –ø—Ä–æ–º–ø—Ç –¥–ª—è GigaChat:\n{planning_prompt}")
    if await gigachat_api.get_token(auth_token):
        result = await gigachat_api.get_chat_completion(
            "–¢—ã –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–¥–∞—á. –°–æ–∑–¥–∞–≤–∞–π –ø–ª–∞–Ω –∏–∑ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö workflow.",
            planning_prompt
        )
        try:
            plan = json.loads(result['response'])
            if not isinstance(plan, list):
                raise ValueError("–ü–ª–∞–Ω –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞—Å—Å–∏–≤–æ–º")
            for step in plan:
                if 'workflow_id' not in step:
                    raise ValueError("–ö–∞–∂–¥—ã–π —à–∞–≥ –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å workflow_id")
            return plan
        except (json.JSONDecodeError, ValueError) as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –ø–ª–∞–Ω–∞: {result['response']}. –û—à–∏–±–∫–∞: {e}")
            raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø–ª–∞–Ω –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è.")
    else:
        raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –≤ GigaChat API –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞–Ω–∞")

async def create_new_orchestrator_session(dispatcher_id: str, sessions: Dict, config: Dict, input_data: Dict[str, Any], gigachat_api: GigaChatAPI, label_to_id_map, all_results):
    """–°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é –∏ –ø–ª–∞–Ω –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è"""
    session_id = str(uuid.uuid4())
    query_template = config.get('userQueryTemplate') or '{{ input.query }}'
    user_query = replace_templates(query_template, input_data, label_to_id_map, all_results).strip()

    if not user_query:
        raise Exception("Orchestrator: User query not found in input data.")

    plan = await create_execution_plan(config, user_query, gigachat_api)

    sessions[session_id] = {
        "plan": plan,
        "current_step": 0,
        "initial_query": user_query,
        "execution_history": [],
        "is_agent_mode": config.get('is_agent_mode', False),
        "dispatcher_config": config, # Store node config for re-planning
        "accumulated_data": {}, # Maintained for compatibility, may be deprecated
        "created_at": datetime.now(),
        "dispatcher_id": dispatcher_id
    }
    
    if plan:
        first_step = plan[0]
        workflow_id = first_step.get('workflow_id')
        if workflow_id:
            # Create the standardized input context for the first step
            workflow_input = {
                "initial_query": user_query,
                "last_step_result": {},  # Exists, but is empty
                "execution_history": [],   # Exists, but is empty
                "dispatcher_context": {
                    "session_id": session_id,
                    "plan": plan,
                    "step": 0,
                    "dispatcher_id": dispatcher_id
                }
            }
            return await launch_workflow_by_id(workflow_id, workflow_input)
    raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∏–ª–∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø–ª–∞–Ω –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è")

async def execute_router_dispatcher(node: Node, label_to_id_map: Dict[str, str], input_data: Dict[str, Any], gigachat_api: GigaChatAPI, all_results: Dict[str, Any]) -> Dict[str, Any]:
    """–ê–≥–µ–Ω—Ç-–¥–∏—Å–ø–µ—Ç—á–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∑–∞–ø—Ä–æ—Å –∏ –≤—ã–±–∏—Ä–∞–µ—Ç –Ω—É–∂–Ω—ã–π workflow."""
    from scripts.core.workflow_engine import execute_workflow_internal
    config = node.data.get('config', {})
    query_template = config.get('userQueryTemplate') or '{{ input.output.text }}'
    user_query = replace_templates(query_template, input_data, label_to_id_map, all_results).strip()

    if not user_query:
        raise Exception("Dispatcher: User query not found in input data.")

    workflow_routes = config.get('routes', {})
    if not workflow_routes:
        raise Exception("Dispatcher: Routes are not configured.")

    category = 'default'
    if config.get('useAI', True):
        auth_token = config.get('dispatcherAuthToken')
        if not auth_token:
            raise Exception("Dispatcher: GigaChat auth token is required for AI mode.")

        dispatcher_prompt = config.get('dispatcherPrompt') or "–û–ø—Ä–µ–¥–µ–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∑–∞–ø—Ä–æ—Å–∞: {–∫–∞—Ç–µ–≥–æ—Ä–∏–∏}. –ó–∞–ø—Ä–æ—Å: {–∑–∞–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è}. –û—Ç–≤–µ—Ç—å –æ–¥–Ω–∏–º —Å–ª–æ–≤–æ–º."
        categories_str = ", ".join(workflow_routes.keys())
        classification_prompt = dispatcher_prompt.replace("{–∫–∞—Ç–µ–≥–æ—Ä–∏–∏}", categories_str).replace("{–∑–∞–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è}", user_query)
        logger.info(f"AI classification prompt:\n{classification_prompt}")
        
        if await gigachat_api.get_token(auth_token):
            gigachat_result = await gigachat_api.get_chat_completion("–¢—ã - –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∑–∞–ø—Ä–æ—Å–æ–≤.", classification_prompt)
            
            # NEW: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—ã–∑–æ–≤ API –±—ã–ª —É—Å–ø–µ—à–Ω—ã–º
            if gigachat_result and gigachat_result.get('success'):
                response_text = gigachat_result.get('response', 'default').strip().lower()
                if response_text in workflow_routes:
                    category = response_text
            else:
                # NEW: –ï—Å–ª–∏ API –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É, –ª–æ–≥–∏—Ä—É–µ–º –µ–µ –∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º 'default'
                logger.error(f"GigaChat API call failed: {gigachat_result.get('error')}. Falling back to 'default' category.")
                # category —É–∂–µ 'default', —Ç–∞–∫ —á—Ç–æ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π –Ω–µ –Ω—É–∂–Ω–æ
        else:
             logger.error("Dispatcher: Failed to get GigaChat token.")
    else:
        query_lower = user_query.lower()
        for cat_name, cat_info in workflow_routes.items():
            if cat_name != 'default' and 'keywords' in cat_info:
                if any(keyword.lower() in query_lower for keyword in cat_info['keywords']):
                    category = cat_name
                    break

    selected_route = workflow_routes.get(category, workflow_routes.get('default'))
    if not selected_route:
        raise Exception(f"Dispatcher: No route found for category '{category}'.")

    workflow_id = selected_route['workflow_id']
    workflow_data_raw = await get_workflow_by_id(workflow_id)
    if not workflow_data_raw:
        raise Exception(f"Dispatcher: Target workflow '{workflow_id}' not found.")

    workflow_data = dict(workflow_data_raw)
    nodes = json.loads(workflow_data.get('nodes', '[]'))
    connections = json.loads(workflow_data.get('connections', '[]'))

    workflow_request = WorkflowExecuteRequest(nodes=nodes, connections=connections)
    
    sub_workflow_result = await execute_workflow_internal(workflow_request, initial_input_data={**input_data, "dispatcher_info": {"category": category}})
    
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ–ª–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç, –∞ –Ω–µ —Ç–æ–ª—å–∫–æ .result
    return sub_workflow_result.dict()

async def execute_orchestrator_dispatcher(node: Node, label_to_id_map: Dict[str, str], input_data: Dict[str, Any], gigachat_api: GigaChatAPI, all_results: Dict[str, Any]):
    """–ü–ª–∞–Ω–∏—Ä—É—é—â–∏–π –¥–∏—Å–ø–µ—Ç—á–µ—Ä - —Å–æ–∑–¥–∞–µ—Ç –ø–ª–∞–Ω –∏ –∫–æ–æ—Ä–¥–∏–Ω–∏—Ä—É–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ"""
    dispatcher_id = node.id
    if dispatcher_id not in dispatcher_sessions:
        dispatcher_sessions[dispatcher_id] = {}
    
    current_dispatcher_sessions = dispatcher_sessions[dispatcher_id]
    
    if input_data.get('return_to_dispatcher'):
        return await handle_workflow_return(dispatcher_id, current_dispatcher_sessions, input_data)
    else:
        return await create_new_orchestrator_session(dispatcher_id, current_dispatcher_sessions, node.data.get('config', {}), input_data, gigachat_api, label_to_id_map, all_results)

# --- –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è-–∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å, –≤—ã–∑—ã–≤–∞–µ–º–∞—è –¥–≤–∏–∂–∫–æ–º --- 

async def execute_dispatcher(node: Node, label_to_id_map: Dict[str, str], input_data: Dict[str, Any], gigachat_api: GigaChatAPI, all_results: Dict[str, Any]) -> Dict[str, Any]:
    """–í—ã–ø–æ–ª–Ω—è–µ—Ç –¥–∏—Å–ø–µ—Ç—á–µ—Ä –≤ —Ä–µ–∂–∏–º–µ router –∏–ª–∏ orchestrator"""
    config = node.data.get('config', {})
    dispatcher_type = config.get('dispatcher_type') or config.get('dispatcherType', 'router')

    logger.info(f"üéØ Executing dispatcher {node.id} in {dispatcher_type} mode")
    
    if dispatcher_type == 'router':
        return await execute_router_dispatcher(node, label_to_id_map, input_data, gigachat_api, all_results)
    elif dispatcher_type == 'orchestrator':
        return await execute_orchestrator_dispatcher(node, label_to_id_map, input_data, gigachat_api, all_results)
    else:
        raise Exception(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞: {dispatcher_type}")

# --- –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –¥–ª—è API --- 

async def process_orchestrator_callback(callback_data: DispatcherCallbackRequest):
    """
    –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–ª–ª–±—ç–∫–æ–≤ –æ—Ç —Å—É–±-–≤–æ—Ä–∫—Ñ–ª–æ—É.
    """
    session_id = callback_data.session_id
    step_result = callback_data.step_result

    logger.info(f"üß† Dispatcher received callback for session {session_id}")

    found_session_info = None
    for disp_id, sessions in dispatcher_sessions.items():
        if session_id in sessions:
            found_session_info = (disp_id, sessions)
            break
    
    if not found_session_info:
        raise Exception(f"Session {session_id} not found in any dispatcher sessions.")

    dispatcher_id, sessions_container = found_session_info

    callback_input_data = {
        "session_id": session_id,
        "return_to_dispatcher": True,
        "workflow_result": step_result
    }

    return await handle_workflow_return(dispatcher_id, sessions_container, callback_input_data)
